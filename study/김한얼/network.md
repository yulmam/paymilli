# 1.컴퓨터 네트워크와 인터넷

1. host or 종단 시스템 : TV, 게임 콘솔, PC 등 네트워크 끝단에 있는 것들

종단 시스템은 통신 링크와 패킷 스위치의 네트워크로 연결된다. 이때 링크는 전송률(링크 대역폭을 이용한다)

## 프로토콜 계층화

### 애플리케이션 계층

- HTTP, SMTP, FTP 같은 프로토콜을 포함한다.
- [www.ietf.org](http://www.ietf.org) 같은 주소를 32비트 네트워크 주소로 변환하는 것을 애플리케이션 계층에서 DNS가 돕는다.

### 트랜스포트 계층

- tcp와 udp라는 두 가지 트랜스포트 프로토콜이 있으며 이들은 애플리케이션 계층 메시지를 전달한다.
- 트랜스포트 계층 패킷을 세그먼트라고 한다.

### 네트워크 계층

- 네트워크 계층에서는 패킷을 데이터그램이라고 한다.
- 한 호스트에서 다른 호스트로 라우팅을하는 책임을 가진다.
- IP 데이터그램의 필드를 정의하며 종단 시스템과 라우터가 이 필드에 어떻게 동작하는지를 정의하는 프로토콜을 가진다. IP 프로토콜이 여기에 해당하낟.

### 링크 계층

- 경로상의 한 노드에서 다른 노드로 패킷을 이동하기 위해 네트워크 계층은 링크 계층 서비스에 의존한다.
- 이 계층에서 패킷을 프레임이라고 한다.
- 링크 계층의 프로토콜의 예는 이더넷, 와이파이, 케이블 접속 등이 있다.

### 물리 계층

- 프레임 내부의 각 비트를 한 노드에서 다음 노드로 이동 하는 것이다.
- 실제 케이블 들에 의존한다.

클라이언트 서버 구조에서 클라이언트는 서로 직접 통신하지 않는다. 

이 구조에서는 서버는 고정된 IP 주소라는 잘 알려진 주소를 가진다. 이러한 서버의 경우 하나의 서버가 요청을 다 받지 않으므로 데이터 센터로 가상의 서버를 생성한다.

P2P 구조에서는 항상 켜져있는 은파라스트럭처 서버에 최소로 의존한다.

- 자가 확장성이 있다.

프로세스는 소켓을 통해 네트워크로 메시지를 보내고 받는다.

### 지속 연결과 비지속 연결

각 요구/응답 쌍이 분리된 TCP 연결을 통해져 보내져야 할때 : 비지속 연결

모든 요구화 해당하는 응답들이 같은 TCP 연결 상에서 보내져야 할 때 : 지속 연결

### 비지속 연결

연결 수행 과정 

1. HTTP 클라이언트가 HTTP의 기본 포트번호 80을 통해 url 서버로 TCP 연결을 시도한다. TCP 연결과 관련해 각각에 소켓이 있게 된다.
2. HTTP 클라이언트는 연결된 소켓을 통해 HTTP 요청 메시지를 보낸다.
3. HTTP 서버는 1단계에서 설정 연결 소켓을 통해 요청 메시지를 받는다. 그리고 저장장치로 부터 해당 객체를 추출하여 응답메시지에 해당 객체를 캡슐화 한다. 그리고 응답 메시지를 소켓을 통해 클라이언트로 보낸다.
4. HTTP 서버는 TCP에게 TCP 연결을 끊으라고 한다.(TCP 클라이언트가 응답메시지를 올바로 받을때까지 연결을 끊지 않음)
5. 클라이언트가 응답 메시지를 받으면, TCP 연결이 중단된다.

비지속 연결의 단점

- 각 요청 객체에 대한 새로운 연결이 설정되고 유지되어야 한다.
- 각 객체는 2RTT를 요구한다. (지속 연결에서는 진행중인 요구에 대한 응답을 기다리지 않고 연속해서 만들어질 수 있다.)

요청 메시지 포맷

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/2bdacfc4-1053-4ee1-a39b-62244cca102a/8101ba18-6f02-4669-9dea-5febee49267e/image.png)

응답 메시지 포맷

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/2bdacfc4-1053-4ee1-a39b-62244cca102a/aee92cb4-2a3c-42ae-a22a-3cc742c907e0/image.png)

간단한 상태코드 정리

200 OK : 요청이 성공했고 정보가 응답으로 보내졌다.

301 Moved Permanently : 요청 객체가 영원히 이동되었다. 새로운 URL은 응답 메시지의 Location: 해더에 나와 있다.

400 Bad Request : 서버가 요청을 이해할 수 없다는 일반 오류 코드다.

404 Not Found : 요청 문서가 서버에 존재하지 않는다.

505 HTTP Version Not Supported : 요청 HTTP 프로토콜 버전을 서버가 지원하지 않는다.

## 쿠키!!!

HTTP의 경우 상태를 유지하지 않는다. 이러한 점은 서버 설계를 간편하게 하고 동시에 수천 개의 TCP 연결을 다룰 수 있는 고성능의 웹서버를 개발하게 해주 었으나 웹사이트는 사용자를 확인할 필요가 있다.

쿠키 기술 요소

1. HTTP 응답 메시지 쿠키 헤더라인
2. HTTP 요청 메시지 쿠키 헤더라인
3. 사용자의 브라우저에 사용자 종단 시스템과 관리를 지속시키는 쿠키 파일
4. 웹사이트의 백엔드 데이터베이스

시나리오

1. 사용자가 일반적인 http request msg를 보낸다.
2. 사용자에 대한 ID를 생성한다.
3. http response를 보내며 Set-cookie : ID를 한다.
4. 사용자는 쿠키를 저장하고 다음에 http request msg를 보낼 경우 cookie의 값을 헤더에 담아 보낸다.
5. 서버는 쿠키를 확인하고 사용자가 인증돼있음을 확인한다.
6. 쿠키는 만료될때까지 사용할 수 있다.

### Session은 그럼 뭔데???

Session은 쿠키를 사용한다.

다만 Session의 경우 서버에 sessionID와 value 값을 가지고 있으며, setCookie 과정에서 sessionName과 SessionID를 저장한다. 

즉!! http request를 받았을 때 sessionID가 있기 때문에 서버에 저장된 SessionID를 기반으로 value 값을 찾아 확인한다.

### 웹 캐싱(프록시)

웹 캐시는 웹 서버를 대신하여 HTTP 요구를 충족시키는 네트워크 개체다.

- 저장 디스크에 최근 호출된 객체의 사본을 저장 및 보존한다.
- ISP가 구입하고 설치한다.

장점

- 클라이언트의 요구에 대한 응답 시간을 줄일 수 있다.
- 링크 상의 웹 트래픽을 대폭 줄일 수 있다.

시나리오

1. 브라우저는 웹 캐시와 TCP 연결을 설정하고 웹 캐시에 있는 객체에 대한 HTTP 요청을 보낸다.
2. 웹 캐시는 객체의 사본이 자기에게 저장되어 있는지 확인한다. 만일 저장되어 있다면 웹 캐시는 브라우저로 HTTP 응답 메시지와 함께 객체를 전송한다.
3. 만약 없담녀 웹 캐시는 기점 서버에 TCP 연결을 설정하고, 최신화 한다.
4. 웹 캐시의 객체를 수신할 때, 객체를 지역 저장 장치에 복사하고 HTTP 응답 메시지와 함께 객체의 사본을 보낸다.

조건부 GET
웹캐싱이 사용자가 느끼는 응답 시간을 줄일 수 있지만, 캐시 내부에 있는 객체 복사본이 새것이 아닐 수 있다.  이때 사용하는 것이 조건부 GET이다.

- If-Modified-Since : 헤더라인을 포함하고 있다면, 조건부 GET 메시지다.

DNS : 인터넷의 디렉터리 서비스

호스트 이름은 기억하기는 쉽지만 호스트 위치에 대한 정보를 거의 제공하지 않는다. 더 나아가 가변길이이기 떄문에 라우터가 처리하기 힘들다. 그래서 호스트는 IP 주소로 식별이 된다.

DNS란?

- DNS 서버들의 계층구조로 구혀노딘 분산 데이터베이스이다.
- 호스트가 분산데이터베이스로 질의하도록 허락하는 애플리케이션 계층 프로토콜이다.
- DNS서버는 주로BIND 소프트웨어를 수행하는 유닉스 컴퓨터이다. 또한 UDP상에서 수행되며 포트번호는 53번호를 사용한다.